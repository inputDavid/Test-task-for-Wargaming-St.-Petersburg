import random

""" Задание №1 """


# Мы будем определять чётное ли число, смотря на его последнюю цифру
# Если последняя цифра чётная, то и число тоже чётное
def is_number_even(number):
    even_number = [0, 2, 4, 6, 8]
    return number % 10 in even_number


# Приведённая в задании реализация имеет следующие плюсы над моей реализацией:
# Код короче на одну строчку
# Выполняется меньше операций для определения чётности числа
# Мы можем реализовать данный функционал через lambda функцию

# Преимуществ моего варианта, над вариантом из задания я не вижу
# Недостатки вытекают из преимуществ реализации в задании, описанных выше

""" Задание №2 """
# Я не знаком с синтаксисом предыдущих версий языка Python и не сталкивался ранее с понятием циклического буфера.
# Я конечно погуглил, но понял что вопрос этот далеко не поверхностный и пара статей тут не поможет.

""" Задание №3 """


# Поскольку массив может быть любого размера, в том числе и сверх большого, то обычные методы сортировки
# вроде сортировки выбором, сортировки вставками или сортировки пузырьком не подойдут,
# поскольку их время выполнения О(N^2), где N - это число элементов массива.
# Для сортировки массивов с большим количеством элементов, лучше использовать такие алгоритмы как
# сортировка слиянием или быструю сортировку. Их время выполнения О(N*Log2N) (P.S. логарифм по основанию 2),
# где N - это число элементов массива. Я буду использовать быструю сортировку для решения данной задачи.
def quick_sort(arr):
    # Условие выхода из рекурсии
    if len(arr) < 2:  # Массивы с 0 и 1 элементом уже отсортированы
        return arr

    random_number = random.randint(0, len(arr) - 1)  # Рандомный индекс для выбора опорного элемента
    # Будем выбирать рандомный опорный элемент на случай,
    # если мы сортируем уже отсортированный массив
    support_elem = arr[random_number]  # Выбрали рандомный опорный элемент
    left = [i for i in arr if i < support_elem]  # Элементы меньше опорного
    center = [i for i in arr if i == support_elem]  # Элементы равные опорному
    right = [i for i in arr if i > support_elem]  # Элементы больше опорного

    # Собираем списки воедино, рекурсивно вызывая нашу функцию для списков,
    # состоящих из значений меньше и больше опорного элемента
    return quick_sort(left) + center + quick_sort(right)
